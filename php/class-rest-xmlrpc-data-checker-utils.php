<?php
/**
 * Plugin Utils class.
 *
 * @package rest-xmlrpc-data-checker
 * @author Enrico Sorcinelli
 */

namespace REST_XMLRPC_Data_Checker;

/**
 * Class Utils
 */
class Utils {

	/**
	 * Check for AJAX request.
	 *
	 * @return boolean
	 */
	public static function is_ajax_request() {

		if (
			( ! empty( $_SERVER['HTTP_X_REQUESTED_WITH'] ) && strtolower( $_SERVER['HTTP_X_REQUESTED_WITH'] ) === 'xmlhttprequest' ) // WPCS: XSS ok, sanitization ok.
			|| ( defined( 'DOING_AJAX' ) && DOING_AJAX )
		) {
			return true;
		}

		return false;
	}

	/**
	 * Call a template. Return also value returned from `include`.
	 *
	 * @param string|array $template Path of file to include (include_path),
	 *                               function or class method.
	 * @param array|null   $params   Associative array that you could use
	 *                               inside template. Use `$params{key}` in the
	 *                               template to refer to the specific `key`.
	 *
	 * @return mixed
	 */
	public static function include_template( $template, $params = array() ) {

		// WP globals.
		global $wp_query, $wp_style, $wp_registered_sidebars, $sidebars_widgets, $wp_registered_widgets, $posts, $post, $wp_did_header, $wp_rewrite, $wpdb, $wp_version, $wp, $id, $comment, $user_ID;

		// Check for a callable template (function/class method).
		if ( is_callable( $template ) ) {
			return call_user_func( $template, $params );
		}

		// Consider template a file.
		return include $template;
	}

	/**
	 * Call a template by buffering output (like `sprintf`).
	 *
	 * @param string $template Path of file to include (include_path).
	 * @param array  $params   Hash array that you could use inside template.
	 *                         Use `$params{key}` in access to refer to the
	 *                         specific `key`.
	 *
	 * @return mixed Return all standard output generated by template or the
	 *               value returned by template if it doesn't return a scalar
	 *               (i.e an object).
	 */
	public static function sinclude_template( $template, $params = array() ) {

		// WP globals.
		global $wp_query, $wp_style, $wp_registered_sidebars, $sidebars_widgets, $wp_registered_widgets, $posts, $post, $wp_did_header, $wp_rewrite, $wpdb, $wp_version, $wp, $id, $comment, $user_ID;

		ob_start();

		// Check for a callable template (function/class method).
		if ( is_callable( $template ) ) {
			$ret = call_user_func( $template, $params );
		} else {
			$ret = include $template;
		}

		$stdout = ob_get_clean();

		// Include fails.
		if ( false === $ret ) {
			return $ret;
		}

		// Checks return type.
		return ( is_scalar( $ret ) || null === $ret ) ? $stdout : $ret;
	}

	/**
	 * Returns true if `$regex` is a valid regular expression pattern.
	 *
	 * @param mixed $regex Regex to be tested.
	 *
	 * @return boolean
	 */
	public static function is_regex( $regex = null ) {

		// Pattern is broken.
		if ( @preg_match( $regex, null ) === false ) {
			return false;
		}

		// Pattern is valid.
		return true;
	}

	/**
	 * Inserts a new key/value before s specific key in the array.
	 *
	 * @param array $args {
	 *     Array of arguments for constructor.
	 *
	 *     @type string  $key            Array key to insert before.
	 *     @type array   $array          Original array.
	 *     @type array   $new_array      Array to insert.
	 *     @type boolean $force_if_empty Add always even if the keys is empty.
	 * }
	 *
	 * @return array The new array if the key exists.
	 */
	public static function array_insert_before( $args = [] ) {

		// Check array.
		if ( ! is_array( $args['array'] ) || ! is_array( $args['new_array'] ) ) {
			return $args['array'];
		}

		if ( empty( $args['array'] ) && empty( $args['force_if_empty'] ) ) {
			return $args['array'];
		}

		if ( array_key_exists( $args['key'], $args['array'] ) ) {
			$ary = array();
			foreach ( $args['array'] as $key => $val ) {
				if ( $key === $args['key'] ) {
					foreach ( $args['new_array'] as $new_key => $new_val ) {
						$ary[ $new_key ] = $new_val;
					}
				}
				$ary[ $key ] = $val;
			}
			return $ary;
		}
		return $args['array'] + $args['new_array'];
	}

	/**
	 * Recursive version of `wp_parse_args`.
	 *
	 * @param array $a Array.
	 * @param array $b Default value.
	 *
	 * @return array
	 */
	public static function wp_parse_args_recursive( $a, $b ) {
		$a      = (array) $a;
		$b      = (array) $b;
		$result = $b;
		foreach ( $a as $k => &$v ) {
			if ( is_array( $v ) && isset( $result[ $k ] ) ) {
				$result[ $k ] = self::wp_parse_args_recursive( $v, $result[ $k ] );
			} else {
				$result[ $k ] = $v;
			}
		}
		return $result;
	}

	/**
	 * Get remote client IP.
	 *
	 * @return string
	 */
	public static function get_remote_ip() {

		// Check IP from share internet.
		if ( ! empty( $_SERVER['HTTP_CLIENT_IP'] ) ) { // WPCS: XSS ok, sanitization ok.
			$ip = $_SERVER['HTTP_CLIENT_IP']; // WPCS: XSS ok, sanitization ok.
		}
		// Check IP passed from proxy.
		elseif ( ! empty( $_SERVER['HTTP_X_FORWARDED_FOR'] ) ) { // WPCS: XSS ok, sanitization ok.
			$ip = $_SERVER['HTTP_X_FORWARDED_FOR']; // WPCS: XSS ok, sanitization ok.
		} else {
			$ip = $_SERVER['REMOTE_ADDR']; // WPCS: XSS ok, sanitization ok, input var ok.
		}
		return $ip;
	}

	/**
	 * Check IP over network classes.
	 *
	 * @param string $ip       IP address to test.
	 * @param array  $networks IP classes used to test. Allowed formats are
	 *                         192.168.233.0/255.255.255.0 or 192.168.233.0/24.
	 *
	 * @return boolean Returns true if $ip belongs to one of defined $networks.
	 */
	public static function check_network( $ip = '', $networks = array() ) {

		// At least the IP must be defined.
		if ( ! isset( $ip ) ) {
			return false;
		}

		// Make $networks an array, if necessary.
		if ( ! is_array( $networks ) ) {
			$networks = preg_split( '/\s+/', $networks );
		}

		// Cycle over networks.
		foreach ( $networks as $mask ) {
			@list( $net, $bits ) = explode( '/', $mask );
			$bits                = isset( $bits ) ? $bits : 32;
			$bitmask             = -pow( 2, 32 - $bits ) & 0x00000000FFFFFFFF;
			$netmask             = ip2long( $net ) & $bitmask;
			$ip_bits             = ip2long( $ip ) & $bitmask;
			if ( ( $netmask ^ $ip_bits ) == 0 ) {
				return true;
			}
		}

		// IP didn't matched.
		return false;
	}

	/**
	 * Check WordPress version.
	 *
	 * @param string $version  Default to `4.0`.
	 * @param string $operator Default to `>=`.
	 *
	 * @return boolean
	 */
	public static function is_wp_version( $version = '4.0', $operator = '>=' ) {
		global $wp_version;
		return version_compare( $wp_version, $version, $operator );
	}

}
